<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Types · BOLFI.jl</title><meta name="title" content="Data Types · BOLFI.jl"/><meta property="og:title" content="Data Types · BOLFI.jl"/><meta property="twitter:title" content="Data Types · BOLFI.jl"/><meta name="description" content="Documentation for BOLFI.jl."/><meta property="og:description" content="Documentation for BOLFI.jl."/><meta property="twitter:description" content="Documentation for BOLFI.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BOLFI.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">BOLFI.jl</a></li><li><a class="tocitem" href="../lfi/">Likelihood-Free Inference Problem</a></li><li><a class="tocitem" href="../lfss/">Sensor Selection Problem</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li class="is-active"><a class="tocitem" href>Data Types</a><ul class="internal"><li><a class="tocitem" href="#Problem-and-Model"><span>Problem &amp; Model</span></a></li><li><a class="tocitem" href="#Likelihood"><span>Likelihood</span></a></li><li><a class="tocitem" href="#Acquisition-Function"><span>Acquisition Function</span></a></li><li><a class="tocitem" href="#Termination-Condition"><span>Termination Condition</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li><li><a class="tocitem" href="#Samplers"><span>Samplers</span></a></li><li><a class="tocitem" href="#Evaluation-Metric"><span>Evaluation Metric</span></a></li><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../hyperparams/">Hyperparameters</a></li><li><a class="tocitem" href="../example_lfi/">Example: LFI</a></li><li><a class="tocitem" href="../example_lfss/">Example: LFSS</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Data Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data Types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/soldasim/BOLFI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/soldasim/BOLFI.jl/blob/master/docs/src/types.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Types"><a class="docs-heading-anchor" href="#Data-Types">Data Types</a><a id="Data-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Types" title="Permalink"></a></h1><h2 id="Problem-and-Model"><a class="docs-heading-anchor" href="#Problem-and-Model">Problem &amp; Model</a><a id="Problem-and-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-and-Model" title="Permalink"></a></h2><p>The <code>BolfiProblem</code> structure contains all information about the inference problem, as well as the model hyperparameters.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.BolfiProblem" href="#BOLFI.BolfiProblem"><code>BOLFI.BolfiProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BolfiProblem(X, Y; kwargs...)
BolfiProblem(::ExperimentData; kwargs...)</code></pre><p>Defines the likelihood-free inference problem and stores all data.</p><p><strong>Args</strong></p><p>The initial data are provided either as two column-wise matrices <code>X</code> and <code>Y</code> with inputs and outputs of the simulator respectively, or as an instance of <code>BOSS.ExperimentData</code>.</p><p>Currently, at least one datapoint has to be provided (purely for implementation reasons).</p><p><strong>Kwargs</strong></p><ul><li><code>f::Any</code>: The simulation to be queried for data.</li><li><code>domain::Domain</code>: The parameter domain of the problem.</li><li><code>acquisition::BolfiAcquisition</code>: Defines the acquisition function.</li><li><code>model::SurrogateModel</code>: The surrogate model to be used to model the proxy <code>δ</code>.</li><li><code>likelihood::Likelihood</code>: The likelihood of the experiment observation <code>z_o</code>.</li><li><code>x_prior::MultivariateDistribution</code>: The prior <code>p(x)</code> on the input parameters.</li><li><code>y_sets::Union{Nothing, Matrix{Bool}}</code>: Optional parameter intended for advanced usage.       The binary columns define subsets <code>y_1, ..., y_m</code> of the observation dimensions within <code>y</code>.       The algorithm then trains multiple posteriors <code>p(θ|y_1), ..., p(θ|y_m)</code> simultaneously.       The posteriors can be compared after the run is completed to see which observation subsets are most informative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/problem.jl#L2-L27">source</a></section></article><h2 id="Likelihood"><a class="docs-heading-anchor" href="#Likelihood">Likelihood</a><a id="Likelihood-1"></a><a class="docs-heading-anchor-permalink" href="#Likelihood" title="Permalink"></a></h2><p>The abstract type <code>Likelihood</code> represents the likelihood distribution of the observation <code>z_o</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.Likelihood" href="#BOLFI.Likelihood"><code>BOLFI.Likelihood</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Represents the assumed likelihood of the experiment observation <span>$z_o$</span>.</p><p><strong>Defining a Custom Likelihood</strong></p><p>To define a custom likelihood, create a new subtype of <code>Likelihood</code> and implement the following API;</p><p>Each subtype of <code>Likelihood</code> <em>should</em> implement:</p><ul><li><code>loglike(::Likelihood, z::AbstractVector{&lt;:Real})</code> where <code>z</code> is the simulator output</li><li><code>log_approx_likelihood(::Likelihood, ::BolfiProblem, ::ModelPosterior)</code></li><li><code>log_likelihood_mean(::Likelihood, ::BolfiProblem, ::ModelPosterior)</code></li></ul><p>Each subtype of <code>Likelihood</code> <em>should</em> implement <em>at least one</em> of:</p><ul><li><code>log_sq_likelihood_mean(::Likelihood, ::BolfiProblem, ::ModelPosterior)</code></li><li><code>log_likelihood_variance(::Likelihood, ::BolfiProblem, ::ModelPosterior)</code></li></ul><p>Additionally, the following method is also necessary to implement if <code>BolfiProblem</code> where <code>!isnothing(problem.y_sets)</code> is used:</p><ul><li><code>get_subset(::Likelihood, y_set::AsbtractVector{&lt;:Bool})</code>:</li></ul><p>The following additional methods are provided by default and <em>need not be implemented</em>:</p><ul><li><code>like(::Likelihood, z::AbstractVector{&lt;:Real})</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/likelihood.jl#L2-L25">source</a></section></article><p>The <code>NormalLikelihood</code> assumes that the observation <code>z_o</code> has been drawn from a Gaussian distribution with a known diagonal covariance matrix with the <code>std_obs</code> values on the diagonal. The simulator is used to learn the mean function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.NormalLikelihood" href="#BOLFI.NormalLikelihood"><code>BOLFI.NormalLikelihood</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NormalLikelihood(; z_obs, std_obs)</code></pre><p>The observation is assumed to have been generated from a normal distribution as <code>z_o \sim Normal(f(x), Diagonal(std_obs))</code>. We can use the simulator to query <code>z = f(x)</code>.</p><p><strong>Kwargs</strong></p><ul><li><code>z_obs::Vector{Float64}</code>: The observed values from the real experiment.</li><li><code>std_obs::Union{Vector{Float64}, Nothing}</code>: The standard deviations of the Gaussian       observation noise on each dimension of the &quot;ground truth&quot; observation.       (If the observation is considered to be generated from the simulator and not some &quot;real&quot; experiment,       provide <code>std_obs = nothing</code>` and the adaptively trained simulation noise deviation will be used       in place of the experiment noise deviation as well. This may be the case for some toy problems or benchmarks.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/likelihoods/normal.jl#L2-L15">source</a></section></article><p>The <code>LogNormalLikelihood</code> assumes that the observation <code>z_o</code> has been drawn from a log-normal distribution with a known diagonal covariance matrix with the <code>std_obs</code> values on the diagonal. The simulator is used to learn the mean function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.LogNormalLikelihood" href="#BOLFI.LogNormalLikelihood"><code>BOLFI.LogNormalLikelihood</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LogNormalLikelihood(; z_obs, std_obs)</code></pre><p>The observation is assumed to have been generated from a normal distribution as <code>z_o \sim LogNormal(f(x), Diagonal(std_obs))</code>. We can use the simulator to query <code>z = f(x)</code>.</p><p>In many cases, one may want to take the logarithm of the output of the simulator. Meaning, if one has simulator <code>z = sim(x)</code>, one would define <code>f</code> as <code>y = f(x) = log(sim(x))</code>. This way, the <code>y</code> values with high likelihood will have similar values to the <code>z</code> values.</p><p><strong>Kwargs</strong></p><ul><li><code>z_obs::Vector{Float64}</code>: The observed values from the real experiment.</li><li><code>std_obs::Vector{Float64}</code>: The standard deviations of the LogNormal observation noise.       (If the observation is considered to be generated from the simulator and not some &quot;real&quot; experiment,       provide <code>std_obs = nothing</code>` and the adaptively trained simulation noise deviation will be used       in place of the experiment noise deviation as well. This may be the case for some toy problems or benchmarks.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/likelihoods/lognormal.jl#L2-L18">source</a></section></article><p>The <code>BinomialLikelihood</code> assumes that the observation <code>z_o</code> has been drawn from a Binomial distribution with a known number <code>trials</code>. The simulator is used to learn the probability parameter <code>p</code> as a function of the input parameters. The expectation over this likelihood (in case one wants to use <code>posterior_mean</code> and/or <code>posterior_variance</code>) is calculated via simple numerical integration on a predefined grid.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.BinomialLikelihood" href="#BOLFI.BinomialLikelihood"><code>BOLFI.BinomialLikelihood</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BinomialLikelihood(; z_obs, trials, kwargs...)</code></pre><p>The observation is assumed to have been generated from a Binomial distribution as <code>z_o \sim Binomial(trials, f(x))</code>. We can use the simulator to query <code>z = f(x)</code>.</p><p>The simulator should only return values between 0 and 1. The GP estimates are clamped to this range.</p><p><strong>Kwargs</strong></p><ul><li><code>z_obs::Vector{Int64}</code>: The observed values from the real experiment.</li><li><code>trials::Vector{Int64}</code>: The number of trials for each observation dimension.</li><li><code>int_grid_size::Int64</code>: The number of samples used to approximate the expected likelihood.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/likelihoods/binomial.jl#L2-L14">source</a></section></article><p>The <code>ExpLikelihood</code> assumes that the function <code>f</code> of the <a href="#BOLFI.BolfiProblem"><code>BolfiProblem</code></a> already maps the parameters <span>$x$</span> to the log-likelihood <span>$\log p(z_o|y)$</span>. Thus, the <code>ExpLikelihood</code> only exponentiates the surrogate model output <span>$\delta$</span> to obtain the likelihood value.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.ExpLikelihood" href="#BOLFI.ExpLikelihood"><code>BOLFI.ExpLikelihood</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExpLikelihood(; kwargs...)</code></pre><p>Assumes the model approximates the log-likelihood directly (as a scalar). Only exponentiates the model prediction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/likelihoods/exp.jl#L2-L7">source</a></section></article><h2 id="Acquisition-Function"><a class="docs-heading-anchor" href="#Acquisition-Function">Acquisition Function</a><a id="Acquisition-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Acquisition-Function" title="Permalink"></a></h2><p>The abstract type <code>BolfiAcquisition</code> represents the acquisition function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.BolfiAcquisition" href="#BOLFI.BolfiAcquisition"><code>BOLFI.BolfiAcquisition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An abstract type for BOLFI acquisition functions.</p><p><strong><strong>Required</strong> API for subtypes of <code>BolfiAcquisition</code>:</strong></p><ul><li>Implement method <code>(::CustomAcq)(::Type{&lt;:UniFittedParams}, ::BolfiProblem, ::BolfiOptions) -&gt; (x -&gt; ::Real)</code>.</li></ul><p><strong><strong>Optional</strong> API for subtypes of <code>BolfiAcquisition</code>:</strong></p><ul><li>Implement method <code>(::CustomAcq)(::Type{&lt;:MultiFittedParams}, ::BolfiProblem, ::BolfiOptions) -&gt; (x -&gt; ::Real)</code>.   A default fallback is provided for <code>MultiFittedParams</code>, which averages individual acquisition functions for each sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/acquisition.jl#L2-L13">source</a></section></article><p>The <code>MaxVar</code> can be used to solve LFI problems. It maximizes the posterior variance to select the next evaluation point.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.MaxVar" href="#BOLFI.MaxVar"><code>BOLFI.MaxVar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaxVar()</code></pre><p>Selects the new evaluation point by maximizing the variance of the posterior approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/acquisitions/maxvar.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.LogMaxVar" href="#BOLFI.LogMaxVar"><code>BOLFI.LogMaxVar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LogMaxVar()</code></pre><p>Selects the new evaluation point by maximizing the log variance of the posterior approximation.</p><p>The <code>LogMaxVar</code> acquisition is functionally equivalent to <code>MaxVar</code>. Using <code>MaxVar</code> or <code>LogMaxVar</code> can be more/less suitable in different scenarios. Switching between the two can help with numerical stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/acquisitions/logmaxvar.jl#L2-L10">source</a></section></article><p>The <code>EIIG</code> acquisition maximizes the Expected Integrated Information Gain. That is; it attempts to minimize the entropy of the current distribution over the possible parameter posteriors (which is implicitly given by the explicit surrogate model posterior).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.EIIG" href="#BOLFI.EIIG"><code>BOLFI.EIIG</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EIIG(; kwargs...)</code></pre><p>Selects new data point by maximizing the Expected Integrate Information Gain (EIIG).</p><p>The information gain is calculated as the mutual information between the new data point (a vector-valued random variable from a multivariate distribution given by the GPs) and the posterior approximation (a &quot;random function&quot; from a infinite-dimensional distribution).</p><p>Instead of calculating the information gain of the infinite-dimensional parameter posterior function values, <code>EIIG</code> computes the average information gain integrated over the domain.</p><p>The resulting mutual information between the new data point and the functional values of the approximate posterior is estimated by calculating the maximum mean discrepancy (MMD) between their joint and marginal distributions. This is also known as  the Hilbert-Schmidt independence criterion (HSIC).</p><p>The random function (an infinite-dimensional random variable) representing the posterior is reduces to samples, which are integrated over. The samples are drawn from the <code>x_proposal</code>.</p><p><strong>Kwargs</strong></p><ul><li><code>x_samples::Int64</code>: The amount of samples used to approximate the integral       over the parameter domain.</li><li><code>samples::Int64</code>: The amount of samples drawn from the joint and marginal distributions       to estimate the HSIC value.</li><li><code>x_proposal::MultivariateDistribution</code>: This distribution is used to sample       parameter samples used to numerically approximate the integral over the parameter domain.</li><li><code>y_kernel::Kernel</code>: The kernel used for the samples of the new data point.</li><li><code>p_kernel::Kernel</code>: The kernel used for the posterior function value samples.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/acquisitions/eiig.jl#L2-L34">source</a></section></article><p>The <code>MWMV</code> can be used to solve LFSS problems. It maximizes the &quot;mass-weighted mean variance&quot; of the posteriors given by the different sensor sets.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.MWMV" href="#BOLFI.MWMV"><code>BOLFI.MWMV</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MWMV(; kwargs...)</code></pre><p>The Mass-Weighted Mean Variance acquisition function.</p><p>Selects the next evaluation point by maximizing a weighted average of the variances of the individual posterior approximations given by different sensor sets. The weights are determined as the total probability mass of the current data w.r.t. each approximate posterior.</p><p><strong>Keywords</strong></p><ul><li><code>samples::Int</code>: The number of samples used to estimate the evidence.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/acquisitions/mwmv.jl#L2-L15">source</a></section></article><h2 id="Termination-Condition"><a class="docs-heading-anchor" href="#Termination-Condition">Termination Condition</a><a id="Termination-Condition-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-Condition" title="Permalink"></a></h2><p>The abstract type <code>BolfiTermCond</code> represents the termination condition for the whole BOLFI procedure. Additionally, any <code>BOSS.TermCond</code> from the BOSS.jl package can be used with BOLFI.jl as well, and it will be automatically converted to a <code>BolfiTermCond</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.BolfiTermCond" href="#BOLFI.BolfiTermCond"><code>BOLFI.BolfiTermCond</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An abstract type for BOLFI termination conditions.</p><p><strong>Implementing custom termination condition:</strong></p><ul><li>Create struct <code>CustomTermCond &lt;: BolfiTermCond</code></li><li>Implement method <code>(::CustomTermCond)(::BolfiProblem) -&gt; ::Bool</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/term_cond.jl#L2-L8">source</a></section></article><p>The most basic termination condition is the <code>BOSS.IterLimit</code>, which can be used to simply terminate the procedure after a predefined number of iterations.</p><p>BOLFI.jl provides two specialized termination conditions; the <code>AEConfidence</code>, and the <code>UBLBConfidence</code>. Both of them estimate the degree of convergence by comparing confidence regions given by two different approximations of the posterior.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.AEConfidence" href="#BOLFI.AEConfidence"><code>BOLFI.AEConfidence</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AEConfidence(; kwargs...)</code></pre><p>Calculates the <code>q</code>-confidence region of the expected and the approximate posteriors. Terminates after the IoU of the two confidence regions surpasses <code>r</code>.</p><p><strong>Keywords</strong></p><ul><li><code>max_iters::Union{Nothing, &lt;:Int}</code>: The maximum number of iterations.</li><li><code>samples::Int</code>: The number of samples used to approximate the confidence regions       and their IoU ratio. Only has an effect if <code>isnothing(xs)</code>.</li><li><code>xs::Union{Nothing, &lt;:AbstractMatrix{&lt;:Real}}</code>: Can be used to provide a pre-sampled       set of parameter samples from the <code>x_prior</code> defined in <code>BolfiProblem</code>.</li><li><code>q::Float64</code>: The confidence value of the confidence regions.       Defaults to <code>q = 0.95</code>.</li><li><code>r::Float64</code>: The algorithm terminates once the IoU ratio surpasses <code>r</code>.       Defaults to <code>r = 0.95</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/term_conds/ae_confidence.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.UBLBConfidence" href="#BOLFI.UBLBConfidence"><code>BOLFI.UBLBConfidence</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UBLBConfidence(; kwargs...)</code></pre><p>Calculates the <code>q</code>-confidence region of the UB and LB approximate posterior. Terminates after the IoU of the two confidence intervals surpasses <code>r</code>. The UB and LB confidence intervals are calculated using the GP mean +- <code>n</code> GP stds.</p><p><strong>Keywords</strong></p><ul><li><code>max_iters::Union{Nothing, &lt;:Int}</code>: The maximum number of iterations.</li><li><code>samples::Int</code>: The number of samples used to approximate the confidence regions       and their IoU ratio. Only has an effect if <code>isnothing(xs)</code>.</li><li><code>xs::Union{Nothing, &lt;:AbstractMatrix{&lt;:Real}}</code>: Can be used to provide a pre-sampled       set of parameter samples from the <code>x_prior</code> defined in <code>BolfiProblem</code>.</li><li><code>n::Float64</code>: The number of predictive deviations added/substracted from the GP mean       to get the two posterior approximations. Defaults to <code>n = 1.</code>.</li><li><code>q::Float64</code>: The confidence value of the confidence regions.       Defaults to <code>q = 0.8</code>.</li><li><code>r::Float64</code>: The algorithm terminates once the IoU ratio surpasses <code>r</code>.       Defaults to <code>r = 0.8</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/term_conds/ublb_confidence.jl#L2-L22">source</a></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><p>The <code>BolfiOptions</code> structure can be used to define miscellaneous settings of BOLFI.jl.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.BolfiOptions" href="#BOLFI.BolfiOptions"><code>BOLFI.BolfiOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BolfiOptions(; kwargs...)</code></pre><p>Stores miscellaneous settings.</p><p><strong>Keywords</strong></p><ul><li><code>info::Bool</code>: Setting <code>info=false</code> silences the algorithm.</li><li><code>debug::Bool</code>: Set <code>debug=true</code> to print stactraces of caught optimization errors.</li><li><code>parallel_evals::Symbol</code>: Possible values: <code>:serial</code>, <code>:parallel</code>, <code>:distributed</code>. Defaults to <code>:parallel</code>.       Determines whether to run multiple objective function evaluations       within one batch in serial, parallel, or distributed fashion.       (Only has an effect if batching AM is used.)</li><li><code>callback::Union{&lt;:BossCallback, &lt;:BolfiCallback}</code>: If provided,       the callback will be called before the BO procedure starts and after every iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/options.jl#L2-L16">source</a></section></article><p>The abstract type <code>BolfiCallback</code> can be derived to define a custom callback, which will be called once before the BOLFI procedure starts, and subsequently in every iteration.</p><p>For an example usage of this functionality, see the <a href="https://github.com/soldasim/BOLFI.jl/tree/master/examples/simple">example</a> in the package repository, where a custom callback is used to create the plots.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.BolfiCallback" href="#BOLFI.BolfiCallback"><code>BOLFI.BolfiCallback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>If a callback <code>cb</code> of type <code>BolfiCallback</code> is defined in <code>BolfiOptions</code>, the method <code>cb(::BolfiProblem; kwargs...)</code> will be called in every iteration.</p><pre><code class="nohighlight hljs">cb(problem::BolfiProblem;
    model_fitter::BOSS.ModelFitter,
    acq_maximizer::BOSS.AcquisitionMaximizer,
    term_cond::TermCond,                        # either `BOSS.TermCond` or a `BolfiTermCond` wrapped into `TermCondWrapper`
    options::BossOptions,
    first::Bool,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/callback.jl#L2-L15">source</a></section></article><h2 id="Samplers"><a class="docs-heading-anchor" href="#Samplers">Samplers</a><a id="Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Samplers" title="Permalink"></a></h2><p>The subtypes of <code>DistributionSampler</code> can be used to draw samples from the trained parameter posterior distribution.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.DistributionSampler" href="#BOLFI.DistributionSampler"><code>BOLFI.DistributionSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DistributionSampler</code></pre><p>Subtypes of <code>DistributionSampler</code> are used to sample from a probability distribution.</p><p>Each subtype of <code>DistributionSampler</code> <em>should</em> implement:</p><ul><li><code>sample_posterior(::DistributionSampler, posterior::Function, domain::Domain, count::Int; kwargs...) -&gt; (X, ws)</code></li></ul><p>Each subtype of <code>DistributionSampler</code> <em>may</em> additionally implement:</p><ul><li><code>sample_posterior(::DistributionSampler, likelihood::Function, prior::MultivariateDistribution, domain::Domain, count::Int; kwargs...) -&gt; (X, ws)</code></li></ul><p>See also: <a href="#BOLFI.PureSampler"><code>PureSampler</code></a>, <a href="#BOLFI.WeightedSampler"><code>WeightedSampler</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/sampler.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.PureSampler" href="#BOLFI.PureSampler"><code>BOLFI.PureSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PureSampler &lt;: DistributionSampler</code></pre><p>A <code>DistributionSampler</code> which samples directly from the provided pdf, and always returns samples with uniform weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/sampler.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.WeightedSampler" href="#BOLFI.WeightedSampler"><code>BOLFI.WeightedSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedSampler &lt;: DistributionSampler</code></pre><p>A <code>DistributionSampler</code> which does not sample directly from the pdf, but instead returns samples with non-uniform weights correcting for the sampling bias.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/sampler.jl#L25-L30">source</a></section></article><p>In particular, the following distribution samplers are currently provided.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.RejectionSampler" href="#BOLFI.RejectionSampler"><code>BOLFI.RejectionSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RejectionSampler(; kwargs...)</code></pre><p>A sampler that uses trivial rejection sampling to draw samples from the posterior distribution.</p><p><strong>Keywords</strong></p><ul><li><code>likelihood_maximizer::LikelihoodMaximizer</code>: The optimizer used to find the maximum likelihood value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/samplers/rejection.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.TuringSampler" href="#BOLFI.TuringSampler"><code>BOLFI.TuringSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TuringSampler &lt;: DistributionSampler(; kwargs...)</code></pre><p>Aggregates settings for the <code>sample_posterior</code> function, which uses the Turing.jl package.</p><p><strong>Keywords</strong></p><ul><li><code>sampler::Any</code>: The sampling algorithm used to draw the samples.</li><li><code>warmup::Int</code>: The amount of initial unused &#39;warmup&#39; samples in each chain.</li><li><code>chain_count::Int</code>: The amount of independent chains sampled.</li><li><code>leap_size</code>: Every <code>leap_size</code>-th sample is used from each chain. (To avoid correlated samples.)</li><li><code>parallel</code>: If <code>parallel=true</code> then the chains are sampled in parallel.</li></ul><p><strong>Sampling Process</strong></p><p>In each sampled chain;</p><ul><li>The first <code>warmup</code> samples are discarded.</li><li>From the following <code>leap_size * samples_in_chain</code> samples each <code>leap_size</code>-th is kept.</li></ul><p>Then the samples from all chains are concatenated and returned.</p><p>Total drawn samples:    &#39;chain<em>count * (warmup + leap</em>size * samples<em>in</em>chain)&#39; Total returned samples: &#39;chain<em>count * samples</em>in_chain&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/samplers/turing.jl#L2-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.AMISSampler" href="#BOLFI.AMISSampler"><code>BOLFI.AMISSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AMIS(; kwargs...)</code></pre><p>Adaptive Metropolis Importance Sampling (AMIS) sampler for posterior distributions.</p><p>The sampler first aproximates the posterior distribution by a Laplace approximation centered on the maximum of the posterior, or with a Gaussian mixture model, and draws samples from it in the 0th iteration.</p><p>Afterwards, the AMIS algorithm is run for <code>iters</code> iterations with a simple Gaussian proposal distribution re-fitted in each iteration.</p><p><strong>Keywords</strong></p><ul><li><code>iters::Int</code>: Number of iterations of the AMIS algorithm.</li><li><code>proposal_fitter::DistributionFitter</code>: The algorithm used to re-fit the proposal distribution       in each iteration. Defaults to the <code>AnalyticalFitter</code>.</li><li><code>gauss_mix_options::Union{Nothing, GaussMixOptions}</code>: Options for the Gaussian mixture approximation       used for the 0th iteration. Defaults to <code>nothing</code>, which means the Laplace approximation is used instead.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/samplers/amis/amis.jl#L11-L29">source</a></section></article><h2 id="Evaluation-Metric"><a class="docs-heading-anchor" href="#Evaluation-Metric">Evaluation Metric</a><a id="Evaluation-Metric-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Metric" title="Permalink"></a></h2><p>The subtypes of <code>DistributionMetric</code> can be used to evaluate the quality of the learned parameter posterior distribution.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.DistributionMetric" href="#BOLFI.DistributionMetric"><code>BOLFI.DistributionMetric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Subtypes of <code>DistributionMetric</code> are used to evaluate the quality of the posterior approximation.</p><p>The <code>DistributionMetric</code>s are grouped into two categories; <a href="#BOLFI.SampleMetric"><code>SampleMetric</code></a> and <a href="#BOLFI.PDFMetric"><code>PDFMetric</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/metric.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.SampleMetric" href="#BOLFI.SampleMetric"><code>BOLFI.SampleMetric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>SampleMetric</code> is a subtype of <code>DistributionMetric</code> that evaluates the quality of the posterior approximation based on samples drawn from the true and approximate posteriors.</p><p>Each subtype of <code>SampleMetric</code> <em>should</em> implement:</p><ul><li><code>calculate_metric(::DistributionMetric, true_samples::AbstractMatrix{&lt;:Real}, approx_samples::AbstractMatrix{&lt;:Real}; kwargs...) -&gt; ::Real</code></li></ul><p>See also: <a href="#BOLFI.DistributionMetric"><code>DistributionMetric</code></a>, <a href="#BOLFI.PDFMetric"><code>PDFMetric</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/metric.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.PDFMetric" href="#BOLFI.PDFMetric"><code>BOLFI.PDFMetric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>PDFMetric</code> is a subtype of <code>DistributionMetric</code> that evaluates the quality of the posterior approximation based on the probability density functions (pdfs) of the true and approximate posteriors.</p><p>Each subtype of <code>PDFMetric</code> <em>should</em> implement:</p><ul><li><code>calculate_metric(::DistributionMetric, true_post::Function, approx_post::Function; kwargs...) -&gt; ::Real</code></li></ul><p>See also: <a href="#BOLFI.DistributionMetric"><code>DistributionMetric</code></a>, <a href="#BOLFI.SampleMetric"><code>SampleMetric</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/types/metric.jl#L20-L28">source</a></section></article><p>In particular, the following metrics are currently provided.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.MMDMetric" href="#BOLFI.MMDMetric"><code>BOLFI.MMDMetric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MMDMetric(; kwargs...)</code></pre><p>Measures the quality of the posterior approximation by sampling from the true posterior and the approximate posterior and calculating the Maximum Mean Discrepancy (MMD) between the two sample sets.</p><p><strong>Keywords</strong></p><ul><li><code>kernel::Kernel</code>: The kernel used to calculate the MMD.       It is important to choose appropriate lengthscales for the kernel.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/metrics/mmd.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BOLFI.TVMetric" href="#BOLFI.TVMetric"><code>BOLFI.TVMetric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TVMetric(; kwargs...)</code></pre><p>Measures the quality of the posterior approximation by approximating the Total Variation (TV) distance based on a precomputed parameter grid.</p><p><strong>Keywords</strong></p><ul><li><code>grid::Matrix{Float64}</code>: The parameter grid used to approximate the TV integral.</li><li><code>ws::Vector{Float64}</code>: The weights for the grid points. Should be <code>1 / q(x)</code>,       where <code>q(x)</code> is the probability density function of the distribution       used to sample the grid points.       (<code>1 / domain_area</code> is appropriate for an evenly distributed grid)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/soldasim/BOLFI.jl/blob/9e2dd782c4f34ecfa789214411ce65b5912a6653/src/metrics/tv.jl#L2-L14">source</a></section></article><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><p>[1] Gutmann, Michael U., and Jukka Cor. &quot;Bayesian optimization for likelihood-free inference of simulator-based statistical models.&quot; Journal of Machine Learning Research 17.125 (2016): 1-47.</p><p>[2] Järvenpää, Marko, et al. &quot;Efficient acquisition rules for model-based approximate Bayesian computation.&quot; (2019): 595-622.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Functions</a><a class="docs-footer-nextpage" href="../hyperparams/">Hyperparameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 23 July 2025 21:03">Wednesday 23 July 2025</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
